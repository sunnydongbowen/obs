---
{"dg-publish":true,"dg-permalink":"Linux下与Windows下性能差异","permalink":"/Linux下与Windows下性能差异/","noteIcon":"","created":"2023-07-04","updated":""}
---


---

## 现象
---
我早上起来吃过早饭，复习了一下锁。敲了一个很简单的程序，程序在这里。[[F.计算机学习笔记/Go语言/并发编程基础篇#5.2 读写互斥锁\|并发编程基础篇#5.2 读写互斥锁]] 。

首先，这个程序我以前学习的时候敲过一次了，后来整理博客复习又敲了一次。这应该是第四次了。很简单的一个demo。我在replit敲完跑了一下，结果是这样的。
![Pasted image 20230704114657.png](/img/user/Pasted%20image%2020230704114657.png)

结果我尝试在本地命令行跑了几次
![Pasted image 20230704114744.png](/img/user/Pasted%20image%2020230704114744.png)
结果是这样的。

我的疑问来了，replit主机才0.5核 512M 内存，而我的Windows笔记本是32G内存，8核的CPU啊。跑不过0.5核的在线云练习平台？我不甘心，反复尝试，结合之前在replit练习和我之前在windows本地运行的结果，还是在replit上跑的快！而且差距很大！例如

于是，我在本地的4核4g的Linux虚拟机上又来了一次，发现同样的现象，在Linux上跑的确实快。和操作系统有关系。

## chatgpt回答
---
于是，我问了一下chatgpt，它给我回答是这样的: 

这个差异可能是由于操作系统的线程调度策略不同导致的。在Windows下，默认情况下，线程调度采用抢占式调度，每个线程会有一个时间片来执行任务，当时间片用完后，系统会剥夺该线程的执行权，并重新调度其他线程。这种抢占式调度可能会导致频繁的线程切换，从而增加了程序的执行时间。

而在Linux下，默认情况下，线程调度采用时间片轮转的方式，每个线程会按照一定的时间片轮流执行任务。这种调度方式在多个线程之间切换时开销较小，不会频繁剥夺线程执行权，因此在多线程并发执行时，能够更高效地利用CPU资源，从而减少程序的执行时间。

所以，你观察到的程序在Windows和Linux下执行时间差异较大的情况可能是由于线程调度策略的不同导致的。另外，这个差异也可能受到操作系统的配置和硬件性能等因素的影响。

## 总结
---
最近复习过程中，一直在replit上 go test , 发现自己对go的理解又更深入了一些。直接在Linux命令行跑，和在windows下goland里编程。差距还是很大的。所以在编程过程中，尽量还是在Linux下去跑。而不是Windows。

而作为经常使用Linux的人，其实我更喜欢在Linux下进行操作。




